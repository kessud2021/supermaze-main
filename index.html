<!doctype html>
<html lang="en">
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title id="page-title">SuperMaze v1.3.1</title>
    <meta
      name="google-site-verification"
      content="qVrfVCCwU5GMzBEZ5_5to9JG8WI3jHB9g-zB-352JZY"
    />
    <link rel="manifest" href="data:application/manifest+json,{&quot;name&quot;:&quot;SuperMaze&quot;,&quot;short_name&quot;:&quot;SuperMaze&quot;,&quot;description&quot;:&quot;Daily maze challenges, leaderboards, and progression. Play online or offline!&quot;,&quot;start_url&quot;:&quot;/&quot;,&quot;display&quot;:&quot;standalone&quot;,&quot;background_color&quot;:&quot;#ffffff&quot;,&quot;theme_color&quot;:&quot;#2d2d2d&quot;,&quot;orientation&quot;:&quot;portrait-primary&quot;,&quot;scope&quot;:&quot;/&quot;,&quot;icons&quot;:[{&quot;src&quot;:&quot;data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 192 192%27%3E%3Crect fill=%27%232d2d2d%27 width=%27192%27 height=%27192%27/%3E%3Crect fill=%27%23e74c3c%27 x=%2740%27 y=%2740%27 width=%2732%27 height=%2732%27 rx=%274%27/%3E%3Crect fill=%27%232ecc71%27 x=%27120%27 y=%27120%27 width=%2732%27 height=%2732%27 rx=%274%27/%3E%3Cpath fill=%27%23333%27 stroke=%27%23fff%27 stroke-width=%272%27 d=%27M72 40 L72 56 L88 56 L88 72 L104 72 L104 88 L72 88 L72 104 L88 104 L88 120 L120 120%27/%3E%3C/svg%3E&quot;,&quot;sizes&quot;:&quot;192x192&quot;,&quot;type&quot;:&quot;image/svg+xml&quot;,&quot;purpose&quot;:&quot;any&quot;},{&quot;src&quot;:&quot;data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 512 512%27%3E%3Crect fill=%27%232d2d2d%27 width=%27512%27 height=%27512%27/%3E%3Crect fill=%27%23e74c3c%27 x=%27104%27 y=%27104%27 width=%2780%27 height=%2780%27 rx=%278%27/%3E%3Crect fill=%27%232ecc71%27 x=%27328%27 y=%27328%27 width=%2780%27 height=%2780%27 rx=%278%27/%3E%3Cpath fill=%27%23333%27 stroke=%27%23fff%27 stroke-width=%276%27 d=%27M184 104 L184 144 L224 144 L224 184 L264 184 L264 224 L184 224 L184 264 L224 264 L224 328 L328 328%27/%3E%3C/svg%3E&quot;,&quot;sizes&quot;:&quot;512x512&quot;,&quot;type&quot;:&quot;image/svg+xml&quot;,&quot;purpose&quot;:&quot;any maskable&quot;}],&quot;screenshots&quot;:[{&quot;src&quot;:&quot;data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 540 720%27%3E%3Crect fill=%27%23f5f5f5%27 width=%27540%27 height=%27720%27/%3E%3Ctext x=%27270%27 y=%27100%27 font-size=%2736%27 font-weight=%27bold%27 text-anchor=%27middle%27 fill=%27%23333%27%3ESuperMaze%3C/text%3E%3Ctext x=%27270%27 y=%27150%27 font-size=%2718%27 text-anchor=%27middle%27 fill=%27%23666%27%3EDaily Challenge%3C/text%3E%3Crect fill=%27%23e8e8e8%27 x=%2730%27 y=%27200%27 width=%27480%27 height=%27480%27 rx=%278%27/%3E%3Ctext x=%27270%27 y=%27500%27 font-size=%2716%27 text-anchor=%27middle%27 fill=%27%23999%27%3EPlay offline anytime%3C/text%3E%3C/svg%3E&quot;,&quot;sizes&quot;:&quot;540x720&quot;,&quot;type&quot;:&quot;image/svg+xml&quot;,&quot;form_factor&quot;:&quot;narrow&quot;}],&quot;categories&quot;:[&quot;games&quot;,&quot;puzzle&quot;],&quot;shortcuts&quot;:[{&quot;name&quot;:&quot;Daily Challenge&quot;,&quot;short_name&quot;:&quot;Daily&quot;,&quot;description&quot;:&quot;Start today's maze challenge&quot;,&quot;url&quot;:&quot;/?mode=daily&quot;,&quot;icons&quot;:[{&quot;src&quot;:&quot;data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 96 96%27%3E%3Crect fill=%27%23e74c3c%27 width=%2796%27 height=%2796%27/%3E%3Ctext x=%2748%27 y=%2760%27 font-size=%2748%27 font-weight=%27bold%27 text-anchor=%27middle%27 fill=%27%23fff%27%3EðŸ“…%3C/text%3E%3C/svg%3E&quot;,&quot;sizes&quot;:&quot;96x96&quot;,&quot;type&quot;:&quot;image/svg+xml&quot;}]},{&quot;name&quot;:&quot;Play Random Maze&quot;,&quot;short_name&quot;:&quot;Random&quot;,&quot;description&quot;:&quot;Play a random maze&quot;,&quot;url&quot;:&quot;/?mode=random&quot;,&quot;icons&quot;:[{&quot;src&quot;:&quot;data:image/svg+xml,%3Csvg xmlns=%27http://www.w3.org/2000/svg%27 viewBox=%270 0 96 96%27%3E%3Crect fill=%27%232ecc71%27 width=%2796%27 height=%2796%27/%3E%3Ctext x=%2748%27 y=%2760%27 font-size=%2748%27 font-weight=%27bold%27 text-anchor=%27middle%27 fill=%27%23fff%27%3EðŸŽ²%3C/text%3E%3C/svg%3E&quot;,&quot;sizes&quot;:&quot;96x96&quot;,&quot;type&quot;:&quot;image/svg+xml&quot;}]}]}" />
    <meta name="theme-color" content="#2d2d2d" />
    <meta name="description" content="SuperMaze - Daily maze challenges, leaderboards, and progression" />
    <link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css" />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.2/dist/css/bootstrap.min.css"
      rel="stylesheet"
    />
    <link
      href="https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css"
      rel="stylesheet"
      integrity="sha384-sRIl4kxILFvY47J16cr9ZwB07vP4J8+LH7qKQnuqkuIAvNWLzeN8tE5YBujZqJLB"
      crossorigin="anonymous"
    />
    <script
      src="https://code.jquery.com/jquery-3.7.1.slim.min.js"
      integrity="sha256-kmHvs0B+OpCW5GVHUNjv9rOmY0IvSIRcf7zGUDTDQM8="
      crossorigin="anonymous"
    ></script>

    <style>
      * {
        box-sizing: border-box;
      }
      html,
      body {
        height: 100%;
        margin: 0;
        font-family: "Segoe UI", sans-serif;
      }
      body {
        display: flex;
        justify-content: center;
        align-items: center;
        transition: background 0.3s ease;
        min-height: 100vh;
      }
      .connect-container {
        display: flex;
        justify-content: center;
        align-items: center;
        height: 100%;
      }
      .connect-card {
        width: 380px;
        border-radius: 14px;
        box-shadow: 0 12px 36px rgba(2, 6, 23, 0.36);
        backdrop-filter: blur(8px);
        background: rgba(255, 255, 255, 0.06);
        border: 1px solid rgba(255, 255, 255, 0.06);
        position: relative;
      }
      .maze-container {
        width: 100%;
        height: 100vh;
        position: relative;
        display: flex;
        justify-content: center;
        align-items: center;
        background: #f5f5f5;
        overflow: hidden;
      }
      .maze-grid {
        display: grid;
        gap: 2px;
      }
      .cell {
        width: 25px;
        height: 25px;
        border-radius: 6px;
        background: #fff;
        transition: background 0.06s;
        box-sizing: border-box;
      }
      .cell.wall {
        background: #333;
      }
      .cell.player {
        background: #e74c3c;
        box-shadow: 0 0 6px rgba(231, 76, 60, 0.7) inset;
      }
      .cell.end {
        background: #2ecc71;
        box-shadow: 0 0 6px rgba(46, 204, 113, 0.6) inset;
      }
      .cell.ghost {
        background: rgba(0, 200, 255, 0.6);
      }
      .keystrokes {
        position: absolute;
        bottom: 18px;
        left: 18px;
        display: flex;
        gap: 6px;
        flex-direction: column;
        color: #fff;
        font-weight: 700;
        text-shadow: 0 0 5px #000;
      }
      .keystrokes span {
        width: 34px;
        height: 34px;
        text-align: center;
        line-height: 34px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.9);
        background: rgba(0, 0, 0, 0.55);
      }
      .stopwatch {
        position: absolute;
        top: 14px;
        right: 14px;
        padding: 6px 10px;
        border-radius: 8px;
        background: rgba(0, 0, 0, 0.7);
        color: #fff;
        font-size: 18px;
      }
      .back-btn {
        position: absolute;
        top: 14px;
        left: 14px;
      }
      .cell.breadcrumb {
        background: #999;
        opacity: 0.5;
      }
      .minimap-container {
        position: absolute;
        bottom: 18px;
        right: 18px;
        background: rgba(0, 0, 0, 0.7);
        border-radius: 8px;
        padding: 8px;
        border: 1px solid rgba(255, 255, 255, 0.3);
      }
      .minimap-canvas {
        display: block;
        background: #222;
        border-radius: 4px;
      }
      @keyframes confetti-fall {
        to {
          transform: translateY(100px) rotate(360deg);
          opacity: 0;
        }
      }
      @keyframes spark-burst {
        to {
          transform: scale(0) translateX(var(--tx)) translateY(var(--ty));
          opacity: 0;
        }
      }
      .particle {
        position: fixed;
        pointer-events: none;
        animation: confetti-fall 1.5s ease-out forwards;
      }
      .particle.spark {
        animation: spark-burst 0.8s ease-out forwards;
      }
      @media (max-width: 480px) {
        .connect-card {
          width: 92%;
        }
        .connect-card.small {
          width: 92%;
        }
      }
      .title-row {
        display: flex;
        align-items: center;
        justify-content: space-between;
        gap: 8px;
      }
      .title-left {
        display: flex;
        align-items: center;
        gap: 10px;
        position: relative;
      }
      .logout-btn-inline {
        background: rgba(239, 68, 68, 0.15);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.3);
        padding: 6px 10px;
        border-radius: 6px;
        font-size: 12px;
        cursor: pointer;
        transition: all 0.2s ease;
        font-weight: 600;
        white-space: nowrap;
      }
      .logout-btn-inline:hover {
        background: rgba(239, 68, 68, 0.3);
        border-color: rgba(239, 68, 68, 0.6);
        transform: translateY(-1px);
      }
      .site-title {
        font-size: 20px;
        font-weight: 700;
        margin: 0;
      }
      .status-pill {
        padding: 6px 10px;
        border-radius: 999px;
        font-weight: 700;
        font-size: 13px;
        display: inline-flex;
        align-items: center;
        gap: 8px;
      }
      .status-online {
        background: rgba(16, 185, 129, 0.14);
        color: #10b981;
        border: 1px solid rgba(16, 185, 129, 0.22);
      }
      .status-offline {
        background: rgba(239, 68, 68, 0.12);
        color: #ef4444;
        border: 1px solid rgba(239, 68, 68, 0.18);
      }
      .join-card .form-control {
        background: rgba(255, 255, 255, 0.04);
        color: inherit;
        border-radius: 10px;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }
      .join-actions {
        display: flex;
        gap: 8px;
        margin-top: 10px;
      }
      .btn-ghost {
        background: rgba(255, 255, 255, 0.03);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.06);
      }

      /* Presets: light, dark, blue, green, pink, red */
      body.theme-light {
        background: linear-gradient(135deg, #f5f5f5, #e8e8e8);
        color: #333;
      }
      body.theme-light .connect-card {
        background: rgba(255, 255, 255, 0.95);
        border: 1px solid rgba(0, 0, 0, 0.1);
        color: #333;
      }
      body.theme-light .site-title {
        color: #333;
      }

      body.theme-dark {
        background: linear-gradient(135deg, #1a1a1a, #2d2d2d);
        color: #e0e0e0;
      }
      body.theme-dark .connect-card {
        background: rgba(30, 30, 30, 0.95);
        border: 1px solid rgba(255, 255, 255, 0.1);
        color: #e0e0e0;
      }
      body.theme-dark .site-title {
        color: #e0e0e0;
      }
      body.theme-dark .form-select,
      body.theme-dark .form-control {
        background-color: #2d2d2d;
        color: #e0e0e0;
        border-color: #444;
      }

      body.theme-blue {
        background: linear-gradient(135deg, #001f3f, #003d99);
        color: #e0f2ff;
      }
      body.theme-blue .connect-card {
        background: rgba(0, 31, 63, 0.9);
        border: 1px solid rgba(0, 150, 255, 0.3);
        color: #e0f2ff;
      }
      body.theme-blue .site-title {
        color: #00d4ff;
      }

      body.theme-green {
        background: linear-gradient(135deg, #1b3d1b, #2d5a2d);
        color: #d0f0d0;
      }
      body.theme-green .connect-card {
        background: rgba(27, 61, 27, 0.9);
        border: 1px solid rgba(76, 175, 80, 0.3);
        color: #d0f0d0;
      }
      body.theme-green .site-title {
        color: #4caf50;
      }

      body.theme-pink {
        background: linear-gradient(135deg, #3d1a2e, #5a2d45);
        color: #f0d0e8;
      }
      body.theme-pink .connect-card {
        background: rgba(61, 26, 46, 0.9);
        border: 1px solid rgba(255, 105, 180, 0.3);
        color: #f0d0e8;
      }
      body.theme-pink .site-title {
        color: #ff69b4;
      }

      body.theme-red {
        background: linear-gradient(135deg, #3d1a1a, #5a2d2d);
        color: #f0d0d0;
      }
      body.theme-red .connect-card {
        background: rgba(61, 26, 26, 0.9);
        border: 1px solid rgba(255, 76, 76, 0.3);
        color: #f0d0d0;
      }
      body.theme-red .site-title {
        color: #ff4444;
      }

      /* Shared theme styles */
      body .form-select,
      body .form-control {
        background-color: rgba(255, 255, 255, 0.1);
        color: inherit;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      body .btn {
        transition: all 0.2s ease;
      }

      /* Customization modal: user-defined theme colors with optional background image */
      .customize-modal {
        position: fixed;
        inset: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.85);
        z-index: 50000;
        padding: 20px;
      }
      .customize-content {
        background: rgba(40, 40, 50, 0.95);
        border-radius: 16px;
        padding: 30px;
        max-width: 500px;
        max-height: 90vh;
        overflow-y: auto;
        color: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      }
      .customize-content::-webkit-scrollbar {
        width: 0;
      }
      .customize-content::-webkit-scrollbar-track {
        background: transparent;
      }
      .customize-content::-webkit-scrollbar-thumb {
        background: transparent;
      }
      .customize-content {
        scrollbar-width: none;
      }
      .customize-title {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 20px;
        color: #00d4ff;
      }
      .customize-group {
        margin-bottom: 18px;
      }
      .customize-group label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #b0b0c0;
      }
      .customize-group input[type="text"],
      .customize-group input[type="color"],
      .customize-group textarea {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-family: inherit;
        box-sizing: border-box;
      }
      .customize-group input[type="color"] {
        height: 45px;
        cursor: pointer;
      }
      .customize-group textarea {
        resize: vertical;
        min-height: 60px;
        font-size: 12px;
      }
      .customize-buttons {
        display: flex;
        gap: 10px;
        margin-top: 25px;
      }
      .customize-buttons button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .customize-buttons .save-btn {
        background: #00d4ff;
        color: #000;
      }
      .customize-buttons .save-btn:hover {
        background: #00f0ff;
        transform: translateY(-2px);
      }
      .customize-buttons .close-btn {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      .customize-buttons .close-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }
      .color-preview {
        display: inline-block;
        width: 30px;
        height: 30px;
        border-radius: 6px;
        border: 1px solid rgba(255, 255, 255, 0.3);
        vertical-align: middle;
        margin-left: 10px;
      }

      /* Settings modal: game difficulty/graphics picker + JSON editor with line numbers */
      .settings-modal {
        position: fixed;
        inset: 0;
        display: flex;
        justify-content: center;
        align-items: center;
        background: rgba(0, 0, 0, 0.85);
        z-index: 50000;
        padding: 20px;
      }
      .settings-content {
        background: rgba(40, 40, 50, 0.95);
        border-radius: 16px;
        padding: 30px;
        max-width: 600px;
        max-height: 85vh;
        overflow-y: auto;
        color: #fff;
        box-shadow: 0 20px 60px rgba(0, 0, 0, 0.8);
      }
      .settings-content::-webkit-scrollbar {
        width: 0;
      }
      .settings-content::-webkit-scrollbar-track {
        background: transparent;
      }
      .settings-content::-webkit-scrollbar-thumb {
        background: transparent;
      }
      .settings-content {
        scrollbar-width: none;
      }
      .settings-title {
        font-size: 24px;
        font-weight: 700;
        margin-bottom: 20px;
        color: #fbbf24;
      }
      .settings-group {
        margin-bottom: 20px;
      }
      .settings-group label {
        display: block;
        font-size: 14px;
        font-weight: 600;
        margin-bottom: 8px;
        color: #b0b0c0;
      }
      .settings-group select,
      .settings-group textarea {
        width: 100%;
        padding: 10px;
        border-radius: 8px;
        border: 1px solid rgba(255, 255, 255, 0.2);
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        font-family: "Courier New", monospace;
        box-sizing: border-box;
      }
      .settings-group textarea {
        resize: vertical;
        min-height: 200px;
        font-size: 12px;
      }
      .settings-group select {
        cursor: pointer;
      }
      .settings-buttons {
        display: flex;
        gap: 10px;
        margin-top: 25px;
      }
      .settings-buttons button {
        flex: 1;
        padding: 12px;
        border: none;
        border-radius: 8px;
        font-weight: 600;
        cursor: pointer;
        transition: all 0.2s ease;
      }
      .settings-buttons .save-btn {
        background: #fbbf24;
        color: #000;
      }
      .settings-buttons .save-btn:hover {
        background: #fcd34d;
        transform: translateY(-2px);
      }
      .settings-buttons .close-btn {
        background: rgba(255, 255, 255, 0.1);
        color: #fff;
        border: 1px solid rgba(255, 255, 255, 0.2);
      }
      .settings-buttons .close-btn:hover {
        background: rgba(255, 255, 255, 0.15);
      }
      .settings-info {
        font-size: 12px;
        color: #999;
        margin-top: 6px;
      }
      .code-editor-wrapper {
        display: flex;
        border: 1px solid rgba(255, 255, 255, 0.2);
        border-radius: 8px;
        overflow: hidden;
        background: rgba(0, 0, 0, 0.3);
      }
      .code-line-numbers {
        background: rgba(0, 0, 0, 0.5);
        color: #666;
        padding: 10px 8px;
        text-align: right;
        font-family: "Courier New", monospace;
        font-size: 12px;
        line-height: 1.5;
        border-right: 1px solid rgba(255, 255, 255, 0.1);
        user-select: none;
        min-width: 40px;
      }
      .code-editor {
        flex: 1;
        padding: 10px;
        font-family: "Courier New", monospace;
        font-size: 12px;
        background: rgba(0, 0, 0, 0.3);
        color: #fff;
        border: none;
        outline: none;
        line-height: 1.5;
        resize: none;
        overflow: auto;
      }
      .code-editor::-webkit-scrollbar {
        width: 0;
        height: 0;
      }
      .code-editor::-webkit-scrollbar-track {
        background: transparent;
      }
      .code-editor::-webkit-scrollbar-thumb {
        background: transparent;
      }
      .code-editor {
        scrollbar-width: none;
      }
    </style>
  </head>
  <body class="theme-light">
    <!-- INITIAL_LOGIN: Collect username and show offline status -->
    <div id="username-screen" class="connect-container">
      <div class="card connect-card text-center p-0">
        <div class="card-body">
          <div class="title-row mb-2">
            <div class="title-left">
              <h4 class="site-title">ðŸŒ€ SuperMaze</h4>
            </div>
            <div>
              <span id="global-status" class="status-pill status-offline"
                >ðŸ”Œ Offline</span
              >
            </div>
          </div>
          <div class="mb-3"><small>Enter your username to continue</small></div>
          <input
            id="username-input"
            class="form-control mb-3"
            placeholder="Your username"
          />
          <button id="continue-btn" class="btn btn-primary w-100">
            Continue
          </button>
        </div>
      </div>
    </div>

    <!-- MENU: Game mode, theme, leaderboard, settings selector -->
    <div id="connect-screen" class="connect-container d-none">
      <div class="card connect-card p-0">
        <div class="card-body">
          <div class="title-row mb-2">
            <div class="title-left">
              <h4 class="site-title">ðŸŒ€ SuperMaze</h4>
              <small class="text-muted ms-2">v1.3.1</small>
            </div>
          </div>

          <div class="text-center mb-3">
            <div style="display: flex; gap: 8px; margin-bottom: 8px">
              <button id="single-btn" class="btn btn-success" style="flex: 1">
                Singleplayer
              </button>
              <button
               id="logout-btn"
               class="logout-btn-inline"
               title="Sign out"
              >
               <i class="bi bi-box-arrow-right"></i> Logout
              </button>
            </div>
            <button
              id="replay-list-btn"
              class="btn btn-outline-primary w-100 mb-2 mt-2"
            >
              Saved Replays
            </button>
            <div style="display: flex; gap: 8px; margin-bottom: 12px">
              <select id="theme-select" class="form-select" style="flex: 1">
                <option value="light">Light</option>
                <option value="dark">Dark</option>
                <option value="blue">Blue</option>
                <option value="green">Green</option>
                <option value="pink">Pink</option>
                <option value="red">Red</option>
              </select>
              <button
                 id="customize-btn"
                 class="btn btn-outline-info"
                 title="Customize theme"
               >
                 <i class="bi bi-plus-lg"></i>
               </button>
            </div>
            <div id="xp-info" class="mb-2 text-muted small"></div>
            <div style="display: flex; gap: 8px; margin-bottom: 8px">
              <button
                id="leaderboard-btn"
                class="btn btn-outline-secondary"
                style="flex: 1"
              >
                Leaderboard
              </button>
              <button
                id="settings-btn"
                class="btn btn-outline-warning"
                title="Settings"
              >
                <i class="bi bi-sliders"></i>
              </button>
            </div>
            <button
              id="docs-btn"
              class="btn btn-outline-info w-100"
              title="View documentation"
            >
              Docs
            </button>
          </div>
        </div>
      </div>
    </div>

    <!-- GAMEPLAY: Maze grid, live keystroke indicators, elapsed time, exit button -->
    <div id="maze-screen" class="maze-container d-none">
      <div id="maze-grid" class="maze-grid" aria-hidden="false"></div>
      <div id="keystrokes" class="keystrokes"></div>
      <div id="stopwatch" class="stopwatch">00:00.000</div>
      <div id="minimap-container" class="minimap-container d-none">
        <canvas id="minimap-canvas" class="minimap-canvas" width="120" height="120"></canvas>
      </div>
      <button id="back-btn" class="btn btn-secondary back-btn">Exit</button>
    </div>

    <noscript>
  <style>
    /* Scoped styles just for the noscript message */
    .no-js-overlay {
      position: fixed;
      top: 0;
      left: 0;
      width: 100vw;
      height: 100vh;
      background: #2d2d2d; /* Matches your game theme */
      color: #e0e0e0;
      z-index: 2147483647; /* Maximum possible z-index */
      display: flex;
      flex-direction: column;
      align-items: center;
      justify-content: center;
      text-align: center;
      font-family: "Segoe UI", system-ui, -apple-system, sans-serif;
      padding: 20px;
    }
    .no-js-card {
      background: rgba(255, 255, 255, 0.05);
      border: 1px solid rgba(255, 255, 255, 0.1);
      padding: 40px;
      border-radius: 16px;
      max-width: 500px;
      box-shadow: 0 20px 50px rgba(0,0,0,0.5);
    }
    .no-js-icon {
      font-size: 64px;
      margin-bottom: 20px;
      display: block;
    }
    .no-js-btn {
      margin-top: 20px;
      padding: 10px 20px;
      background: #00d4ff;
      color: #000;
      text-decoration: none;
      font-weight: bold;
      border-radius: 8px;
      display: inline-block;
      transition: opacity 0.2s;
    }
    .no-js-btn:hover {
      opacity: 0.9;
    }
  </style>

  <div class="no-js-overlay">
    <div class="no-js-card">
      <span class="no-js-icon"><i class="bi bi-exclamation-circle-fill"></i></span>
      <h2 style="margin-top: 0;">JavaScript Required</h2>
      <p style="line-height: 1.6; color: #b0b0c0;">
        <strong>SuperMaze</strong> requires JavaScript to generate levels, 
        handle physics, and save your progress.
      </p>
      <p style="font-size: 0.9em; opacity: 0.8;">
        It looks like JavaScript is disabled in your browser settings. 
        Please enable it to continue.
      </p>
      <a href="https://www.enable-javascript.com/" target="_blank" class="no-js-btn">
        How to enable JavaScript
      </a>
      <a href="." class="no-js-btn" style="background: transparent; color: #fff; border: 1px solid rgba(255,255,255,0.2); margin-left: 10px;">
        Reload Page
      </a>
    </div>
  </div>
</noscript>

    <script>
      /* Cache DOM references for frequent updates */
      const usernameScreen = document.getElementById("username-screen");
      const usernameInput = document.getElementById("username-input");
      const continueBtn = document.getElementById("continue-btn");
      const connectScreen = document.getElementById("connect-screen");
      const logoutBtn = document.getElementById("logout-btn");
      const mazeScreen = document.getElementById("maze-screen");
      const mazeGrid = document.getElementById("maze-grid");
      const themeSelect = document.getElementById("theme-select");
      const customizeBtn = document.getElementById("customize-btn");
      const xpInfo = document.getElementById("xp-info");
      const singleBtn = document.getElementById("single-btn");
      const replayListBtn = document.getElementById("replay-list-btn");
      const leaderboardBtn = document.getElementById("leaderboard-btn");
      const settingsBtn = document.getElementById("settings-btn");
      const docsBtn = document.getElementById("docs-btn");
      const backBtn = document.getElementById("back-btn");
      const keystrokesDiv = document.getElementById("keystrokes");
      const stopwatchDisplay = document.getElementById("stopwatch");
      const serverStatusPill = document.getElementById("server-status-pill");
      const globalStatus = document.getElementById("global-status");

      /* Load difficulty/graphics from localStorage to resume user preferences */
      let gameSettings = {
        difficulty: "medium",
        graphics: "mid",
      };

      const savedSettings = localStorage.getItem("maze_game_settings");
      if (savedSettings) {
        const parsed = sanitizeJSON(savedSettings);
        if (parsed && parsed.difficulty && parsed.graphics) {
          gameSettings = parsed;
        }
      }

      let size = 21,
        cellPx = 25;
      let maze = [],
        player = { x: 1, y: 1 },
        endCell = { x: size - 2, y: size - 2 };
      let moving = false,
        gameWon = false,
        startTime = null,
        timerInterval = null;
      let moves = [],
        replayMode = false;
      let xp = parseInt(localStorage.getItem("maze_xp")) || 0;
      let level = Math.floor(xp / 100);
      let totalSteps = parseInt(localStorage.getItem("maze_total_steps")) || 0;
      let currentSeed = null; // Track current game's seed for sharing

      /* Achievements system */
      const achievements = {
        speedDemon: false,
        pacifist: false,
        marathon: false,
      };
      const savedAchievements = localStorage.getItem("maze_achievements");
      if (savedAchievements) {
        Object.assign(achievements, sanitizeJSON(savedAchievements) || {});
      }

      /* Breadcrumb tracking - visited cells */
      let visitedCells = new Set();

      /* Parse leaderboard with schema validation (username: string, time: positive number) */
      const leaderboardRaw = localStorage.getItem("maze_leaderboard") || "[]";
      let leaderboard = [];
      try {
        const parsed = JSON.parse(leaderboardRaw);
        if (Array.isArray(parsed)) {
          leaderboard = parsed.filter((entry) => {
            return (
              entry &&
              typeof entry.username === "string" &&
              typeof entry.time === "number" &&
              entry.time > 0
            );
          });
        }
      } catch {
        leaderboard = [];
        localStorage.removeItem("maze_leaderboard");
      }

      /* Generate persistent session token on first run (used for tracking) */
      let authToken = localStorage.getItem("maze_auth_token");
      if (!authToken) {
        authToken =
          "user_" + Math.random().toString(36).slice(2, 9) + "_" + Date.now();
        localStorage.setItem("maze_auth_token", authToken);
      }

      function clone2D(arr) {
        // Deep copy for maze snapshots in replays
        return arr.map((r) => r.slice());
      }
      function now() {
        return performance.now();
      }
      function formatTime(ms) {
        // Convert milliseconds to MM:SS.mmm format
        if (!ms) return "00:00.000";
        const s = ms / 1000,
          m = Math.floor(s / 60),
          sec = Math.floor(s % 60),
          msr = Math.floor(ms % 1000);
        return `${String(m).padStart(2, "0")}:${String(sec).padStart(
          2,
          "0",
        )}.${String(msr).padStart(3, "0")}`;
      }

      /* SECURITY: Input sanitizers prevent XSS and malformed data */
      function sanitizeInput(input) {
        // Encode all HTML entities
        const div = document.createElement("div");
        div.textContent = String(input);
        return div.innerHTML;
      }
      function sanitizeUsername(name) {
        // Max 32 chars; remove HTML special chars
        return String(name)
          .replace(/[<>\"'&`]/g, "")
          .substring(0, 32)
          .trim();
      }
      function sanitizeUrl(url) {
        // Prevent javascript: and data: protocol attacks
        if (!url) return "";
        const trimmed = String(url).trim();
        if (trimmed.toLowerCase().startsWith("javascript:")) return "";
        if (trimmed.toLowerCase().startsWith("data:")) return "";
        try {
          new URL(trimmed);
          return trimmed;
        } catch {
          return "";
        }
      }
      function sanitizeColor(color) {
        // Only allow valid hex colors (#RGB or #RRGGBB)
        const match = String(color).match(/^#([0-9a-f]{6}|[0-9a-f]{3})$/i);
        return match ? match[0] : "#000000";
      }
      function sanitizeJSON(jsonString) {
        // Parse and validate structure before use
        try {
          const parsed = JSON.parse(jsonString);
          if (typeof parsed !== "object") return null;
          return parsed;
        } catch {
          return null;
        }
      }

      function updateXPDisplay() {
        // Show username, level, and XP in menu
        xpInfo.textContent = `${
          username || "Guest"
        } | Level ${level} | XP: ${xp}`;
      }

      function getAuthToken() {
        // Return session token for tracking
        return authToken;
      }

      /* Particle Effects */
      function createParticles(x, y, type = "confetti", count = 8) {
        const colors = ["#ff6b6b", "#4ecdc4", "#45b7d1", "#96ceb4", "#ffeaa7"];
        for (let i = 0; i < count; i++) {
          const particle = document.createElement("div");
          particle.className = "particle" + (type === "spark" ? " spark" : "");
          const size = Math.random() * 8 + 4;
          const color = colors[Math.floor(Math.random() * colors.length)];
          const angle = (i / count) * Math.PI * 2;
          const velocity = Math.random() * 100 + 50;

          Object.assign(particle.style, {
            left: x + "px",
            top: y + "px",
            width: size + "px",
            height: size + "px",
            backgroundColor: color,
            borderRadius: "50%",
            "--tx": Math.cos(angle) * velocity + "px",
            "--ty": Math.sin(angle) * velocity + "px",
          });

          document.body.appendChild(particle);
          setTimeout(() => particle.remove(), type === "spark" ? 800 : 1500);
        }
      }

      /* Minimap rendering for large mazes */
      function renderMinimap() {
        const canvas = document.getElementById("minimap-canvas");
        if (!canvas || size <= 25) return;

        const ctx = canvas.getContext("2d");
        const scale = canvas.width / size;

        ctx.fillStyle = "#222";
        ctx.fillRect(0, 0, canvas.width, canvas.height);

        // Draw walls
        ctx.fillStyle = "#333";
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            if (maze[y][x] === 1) {
              ctx.fillRect(x * scale, y * scale, scale, scale);
            }
          }
        }

        // Draw goal
        ctx.fillStyle = "#2ecc71";
        ctx.fillRect(
          endCell.x * scale,
          endCell.y * scale,
          scale,
          scale
        );

        // Draw player
        ctx.fillStyle = "#e74c3c";
        ctx.fillRect(
          player.x * scale,
          player.y * scale,
          scale,
          scale
        );
      }

      function logout() {
        // Clear username from storage and reset UI
        if (confirm("Are you sure you want to log out?")) {
          localStorage.removeItem("maze_username");
          username = "";
          usernameInput.value = "";
          connectScreen.classList.add("d-none");
          mazeScreen.classList.add("d-none");
          usernameScreen.classList.remove("d-none");
          resetGame();
        }
      }

      /* Parse URL parameters EARLY - before username logic */
      let hasChallengeLink = false;
      function parseChallengeLinkParameters() {
        const params = new URLSearchParams(window.location.search);
        const seed = params.get("seed");
        const sizeParam = params.get("size");

        if (seed) {
          hasChallengeLink = true;
          currentSeed = parseInt(seed);
          
          // Set difficulty
          if (sizeParam === "hard") {
            gameSettings.difficulty = "hard";
            size = 31; // Large maze for hard
          } else if (sizeParam === "medium") {
            size = 21;
          } else {
            size = 21; // Default to medium
          }

          // Generate the seeded maze
          generateMazeWithSeed(currentSeed);
          placePlayerAndEndSeeded(currentSeed);
          visitedCells.clear();
          
          return true;
        }
        return false;
      }
      
      // Call this before username logic
      const hasChallenge = parseChallengeLinkParameters();
      if (!hasChallenge) {
        generateMaze();
      }
      renderMaze();

      /* Load saved username; if found, skip login screen */
      let username = localStorage.getItem("maze_username") || "";
      if (username) {
        username = sanitizeUsername(username);
        usernameScreen.classList.add("d-none");
        // If challenge link exists, go straight to maze; otherwise show menu
        if (hasChallengeLink) {
          connectScreen.classList.add("d-none");
          mazeScreen.classList.remove("d-none");
          startStopwatch();
        } else {
          connectScreen.classList.remove("d-none");
          updateXPDisplay();
        }
      }
      continueBtn.onclick = () => {
        let name = usernameInput.value.trim();
        if (!name) return alert("Enter a username!");
        name = sanitizeUsername(name);
        if (!name) return alert("Username contains invalid characters!");
        username = name;
        localStorage.setItem("maze_username", username);

        usernameScreen.classList.add("d-none");
        // If challenge link exists, go straight to maze; otherwise show menu
        if (hasChallengeLink) {
          connectScreen.classList.add("d-none");
          mazeScreen.classList.remove("d-none");
          startStopwatch();
        } else {
          connectScreen.classList.remove("d-none");
          updateXPDisplay();
        }
      };

      /* Load saved theme and custom theme (if exists) */
      const savedTheme = localStorage.getItem("maze_theme") || "light";
      themeSelect.value = savedTheme;
      document.body.className = "theme-" + savedTheme;

      const customThemeRaw = localStorage.getItem("maze_custom_theme");
      let customTheme = null;
      if (customThemeRaw) {
        customTheme = sanitizeJSON(customThemeRaw);
        if (customTheme && customTheme.bg1 && customTheme.bg2) {
          applyCustomTheme(customTheme);
        } else {
          localStorage.removeItem("maze_custom_theme");
        }
      }

      function applyCustomTheme(theme) {
        // Apply CSS variables and background image if present
        document.documentElement.style.setProperty("--custom-bg1", theme.bg1);
        document.documentElement.style.setProperty("--custom-bg2", theme.bg2);
        document.documentElement.style.setProperty(
          "--custom-card-bg",
          theme.cardBg,
        );
        document.documentElement.style.setProperty("--custom-text", theme.text);
        document.documentElement.style.setProperty(
          "--custom-title",
          theme.title,
        );
        document.documentElement.style.setProperty(
          "--custom-border",
          theme.border,
        );

        if (theme.bgImage) {
          document.body.style.backgroundImage = `url('${theme.bgImage}')`;
          document.body.style.backgroundSize = "cover";
          document.body.style.backgroundPosition = "center";
        } else {
          document.body.style.background = `linear-gradient(135deg, ${theme.bg1}, ${theme.bg2})`;
          document.body.style.backgroundImage = "none";
        }

        document.body.style.color = theme.text;
        const cards = document.querySelectorAll(".connect-card");
        cards.forEach((card) => {
          card.style.background = theme.cardBg;
          card.style.borderColor = theme.border;
          card.style.color = theme.text;
        });
        const titles = document.querySelectorAll(".site-title");
        titles.forEach((t) => (t.style.color = theme.title));
      }

      function showCustomizeModal() {
        // Modal for user-defined theme colors
        const custom = customTheme || {
          bg1: "#001f3f",
          bg2: "#003d99",
          cardBg: "rgba(0, 31, 63, 0.9)",
          text: "#e0f2ff",
          title: "#00d4ff",
          border: "rgba(0, 150, 255, 0.3)",
          bgImage: "",
        };

        /* Sanitize inputs: extract hex colors from rgba, validate URLs */
        const bg1 = sanitizeColor(custom.bg1 || "#001f3f");
        const bg2 = sanitizeColor(custom.bg2 || "#003d99");
        const bgImage = sanitizeUrl(custom.bgImage || "");
        const cardBgColor = sanitizeColor(
          custom.cardBg.match(/#[0-9a-f]{6}/i)?.[0] || "#1f1f2e",
        );
        const textColor = sanitizeColor(
          custom.text.match(/#[0-9a-f]{6}/i)?.[0] || "#e0e0e0",
        );
        const titleColor = sanitizeColor(
          custom.title.match(/#[0-9a-f]{6}/i)?.[0] || "#00d4ff",
        );
        const borderColor = sanitizeColor(
          custom.border.match(/#[0-9a-f]{6}/i)?.[0] || "#00d4ff",
        );

        const modal = document.createElement("div");
        modal.className = "customize-modal";
        const content = document.createElement("div");
        content.className = "customize-content";

        const title = document.createElement("h2");
        title.className = "customize-title";
        title.textContent = "ðŸŽ¨ Customize Theme";
        content.appendChild(title);

        /* Helper: color input + label */
        const createColorGroup = (label, inputId, value) => {
          const group = document.createElement("div");
          group.className = "customize-group";
          const lbl = document.createElement("label");
          lbl.textContent = label;
          const input = document.createElement("input");
          input.type = "color";
          input.id = inputId;
          input.value = value;
          group.appendChild(lbl);
          group.appendChild(input);
          return group;
        };

        /* Helper: text input with optional help text */
        const createTextGroup = (
          label,
          inputId,
          value,
          placeholder,
          helpText,
        ) => {
          const group = document.createElement("div");
          group.className = "customize-group";
          const lbl = document.createElement("label");
          lbl.textContent = label;
          const input = document.createElement("input");
          input.type = "text";
          input.id = inputId;
          input.value = value;
          input.placeholder = placeholder;
          group.appendChild(lbl);
          group.appendChild(input);
          if (helpText) {
            const help = document.createElement("small");
            help.style.color = "#999";
            help.style.display = "block";
            help.style.marginTop = "6px";
            help.textContent = helpText;
            group.appendChild(help);
          }
          return group;
        };

        content.appendChild(
          createColorGroup(
            "Background Color 1 (Gradient Start)",
            "custom-bg1",
            bg1,
          ),
        );
        content.appendChild(
          createColorGroup(
            "Background Color 2 (Gradient End)",
            "custom-bg2",
            bg2,
          ),
        );
        content.appendChild(
          createTextGroup(
            "Background Image URL (optional)",
            "custom-bg-image",
            bgImage,
            "https://example.com/image.jpg",
            "Leave empty to use gradient",
          ),
        );
        content.appendChild(
          createColorGroup(
            "Card Background Color",
            "custom-card-bg",
            cardBgColor,
          ),
        );
        content.appendChild(
          createColorGroup("Text Color", "custom-text", textColor),
        );
        content.appendChild(
          createColorGroup("Title Color", "custom-title", titleColor),
        );
        content.appendChild(
          createColorGroup("Border Color", "custom-border", borderColor),
        );

        const btnGroup = document.createElement("div");
        btnGroup.className = "customize-buttons";
        const saveBtnEl = document.createElement("button");
        saveBtnEl.className = "save-btn";
        saveBtnEl.innerHTML = '<i class="bi bi-download"></i> Save Custom Theme';
        const closeBtnEl = document.createElement("button");
        closeBtnEl.className = "close-btn";
        closeBtnEl.textContent = "Cancel";
        btnGroup.appendChild(saveBtnEl);
        btnGroup.appendChild(closeBtnEl);
        content.appendChild(btnGroup);

        modal.appendChild(content);
        document.body.appendChild(modal);

        const saveBtn = modal.querySelector(".save-btn");
        const closeBtn = modal.querySelector(".close-btn");

        saveBtn.onclick = () => {
          const customData = {
            bg1: sanitizeColor(document.getElementById("custom-bg1").value),
            bg2: sanitizeColor(document.getElementById("custom-bg2").value),
            cardBg: sanitizeColor(
              document.getElementById("custom-card-bg").value,
            ),
            text: sanitizeColor(document.getElementById("custom-text").value),
            title: sanitizeColor(document.getElementById("custom-title").value),
            border: sanitizeColor(
              document.getElementById("custom-border").value,
            ),
            bgImage: sanitizeUrl(
              document.getElementById("custom-bg-image").value,
            ),
          };
          localStorage.setItem("maze_custom_theme", JSON.stringify(customData));
          applyCustomTheme(customData);
          modal.remove();
          alert("âœ… Custom theme saved!");
        };

        closeBtn.onclick = () => modal.remove();
      }

      customizeBtn.onclick = showCustomizeModal;

      themeSelect.onchange = () => {
        const theme = themeSelect.value;
        document.body.className = "theme-" + theme;
        localStorage.setItem("maze_theme", theme);
      };

      /* MAZE_GENERATION: Recursive backtracker algorithm (depth-first, carves paths) */
      function initWallGrid() {
        // Fill grid with 1s (walls)
        maze = new Array(size);
        for (let y = 0; y < size; y++) maze[y] = new Array(size).fill(1);
      }
      function carveMaze() {
        // Depth-first with backtracking: visit unvisited neighbors 2 cells away
        initWallGrid();
        const stack = [];
        const start = { x: 1, y: 1 };
        maze[start.y][start.x] = 0;
        stack.push(start);
        const dirs = [
          { dx: 0, dy: -2 },
          { dx: 2, dy: 0 },
          { dx: 0, dy: 2 },
          { dx: -2, dy: 0 },
        ];
        while (stack.length) {
          const cur = stack[stack.length - 1];
          const neighbors = [];
          for (const d of dirs) {
            const nx = cur.x + d.dx,
              ny = cur.y + d.dy;
            if (
              ny > 0 &&
              ny < size - 1 &&
              nx > 0 &&
              nx < size - 1 &&
              maze[ny][nx] === 1
            )
              neighbors.push({ x: nx, y: ny, via: d });
          }
          if (neighbors.length === 0) stack.pop();
          else {
            const n = neighbors[Math.floor(Math.random() * neighbors.length)];
            maze[cur.y + n.via.dy / 2][cur.x + n.via.dx / 2] = 0; // Carve wall between cells
            maze[n.y][n.x] = 0;
            stack.push({ x: n.x, y: n.y });
          }
        }
      }
      function randomEmpty() {
        // Find random unvisited (0) cell; fallback to start
        let attempts = 0;
        while (attempts++ < 10000) {
          const x = 1 + Math.floor(Math.random() * (size - 2));
          const y = 1 + Math.floor(Math.random() * (size - 2));
          if (maze[y][x] === 0) return { x, y };
        }
        return { x: 1, y: 1 };
      }
      function placePlayerAndEnd() {
        // Ensure player and end are >half-maze distance apart
        player = randomEmpty();
        endCell = randomEmpty();
        let tries = 0;
        while (
          Math.abs(player.x - endCell.x) + Math.abs(player.y - endCell.y) <
            Math.floor(size / 2) &&
          tries++ < 2000
        )
          endCell = randomEmpty();
      }
      /* Seeded RNG for Daily Challenge - ensures same maze for all users on same day */
      function seededRandom(seed) {
        const x = Math.sin(seed) * 10000;
        return x - Math.floor(x);
      }
      function getDailySeed() {
        // Convert today's date (YYYY-MM-DD) to a numeric seed
        const today = new Date();
        const dateStr = today.toISOString().split("T")[0]; // e.g., "2025-01-17"
        let hash = 0;
        for (let i = 0; i < dateStr.length; i++) {
          hash = ((hash << 5) - hash) + dateStr.charCodeAt(i);
          hash = hash & hash; // Convert to 32-bit integer
        }
        return Math.abs(hash);
      }
      function generateMazeWithSeed(seed) {
        // Carve maze using seeded RNG
        initWallGrid();
        let rngIndex = seed;
        const seededRand = () => {
          rngIndex = (rngIndex * 1103515245 + 12345) % (2 ** 31);
          return (rngIndex / (2 ** 31)) % 1;
        };

        const stack = [];
        const start = { x: 1, y: 1 };
        maze[start.y][start.x] = 0;
        stack.push(start);
        const dirs = [
          { dx: 0, dy: -2 },
          { dx: 2, dy: 0 },
          { dx: 0, dy: 2 },
          { dx: -2, dy: 0 },
        ];
        while (stack.length) {
          const cur = stack[stack.length - 1];
          const neighbors = [];
          for (const d of dirs) {
            const nx = cur.x + d.dx,
              ny = cur.y + d.dy;
            if (
              ny > 0 &&
              ny < size - 1 &&
              nx > 0 &&
              nx < size - 1 &&
              maze[ny][nx] === 1
            )
              neighbors.push({ x: nx, y: ny, via: d });
          }
          if (neighbors.length === 0) stack.pop();
          else {
            const n = neighbors[Math.floor(seededRand() * neighbors.length)];
            maze[cur.y + n.via.dy / 2][cur.x + n.via.dx / 2] = 0;
            maze[n.y][n.x] = 0;
            stack.push({ x: n.x, y: n.y });
          }
        }
      }
      function placePlayerAndEndSeeded(seed) {
        // Place player and end using seeded RNG
        let rngIndex = seed;
        const seededRand = () => {
          rngIndex = (rngIndex * 1103515245 + 12345) % (2 ** 31);
          return (rngIndex / (2 ** 31)) % 1;
        };

        const randomEmptySeeded = () => {
          let attempts = 0;
          while (attempts++ < 10000) {
            const x = 1 + Math.floor(seededRand() * (size - 2));
            const y = 1 + Math.floor(seededRand() * (size - 2));
            if (maze[y][x] === 0) return { x, y };
          }
          return { x: 1, y: 1 };
        };

        player = randomEmptySeeded();
        endCell = randomEmptySeeded();
        let tries = 0;
        while (
          Math.abs(player.x - endCell.x) + Math.abs(player.y - endCell.y) <
            Math.floor(size / 2) &&
          tries++ < 2000
        )
          endCell = randomEmptySeeded();
      }
      function generateDailyChallenge() {
        // Generate today's maze based on date seed
        const seed = getDailySeed();
        currentSeed = seed;
        generateMazeWithSeed(seed);
        placePlayerAndEndSeeded(seed);
      }
      function generateMaze() {
        carveMaze();
        placePlayerAndEnd();
      }

      /* Render grid cells; highlight player, goal, and replay ghost position */
      function renderMaze(ghostPos = null) {
        mazeGrid.innerHTML = "";
        mazeGrid.style.gridTemplateColumns = `repeat(${size}, ${cellPx}px)`;
        mazeGrid.style.gridTemplateRows = `repeat(${size}, ${cellPx}px)`;
        const frag = document.createDocumentFragment();
        for (let y = 0; y < size; y++) {
          for (let x = 0; x < size; x++) {
            const d = document.createElement("div");
            d.className = "cell";
            if (maze[y][x] === 1) d.classList.add("wall");
            // Show breadcrumbs (visited cells)
            if (visitedCells.has(`${x},${y}`) && !(x === player.x && y === player.y)) {
              d.classList.add("breadcrumb");
            }
            /* Prioritize ghost rendering over player (for replay overlay) */
            if (
              x === player.x &&
              y === player.y &&
              !(ghostPos && ghostPos.x === x && ghostPos.y === y)
            )
              d.classList.add("player");
            if (x === endCell.x && y === endCell.y) d.classList.add("end");
            if (ghostPos && ghostPos.x === x && ghostPos.y === y)
              d.classList.add("ghost");
            frag.appendChild(d);
          }
        }
        mazeGrid.appendChild(frag);
      }

      /* Track pressed keys (WASD or arrow keys) to highlight keystroke display */
      const keys = {
        w: false,
        a: false,
        s: false,
        d: false,
        ArrowUp: false,
        ArrowDown: false,
        ArrowLeft: false,
        ArrowRight: false,
      };
      const arrowMap = {
        W: "ArrowUp",
        A: "ArrowLeft",
        S: "ArrowDown",
        D: "ArrowRight",
      };
      function updateKeystrokes() {
        // Highlight active keys in WASD display
        const layout = ["W", "A", "S", "D"];
        keystrokesDiv.innerHTML = "";
        layout.forEach((k) => {
          const span = document.createElement("span");
          span.textContent = k;
          const lower = k.toLowerCase(),
            arrow = arrowMap[k];
          if (keys[lower] || keys[arrow]) span.style.background = "limegreen";
          keystrokesDiv.appendChild(span);
        });
      }
      /* Continuous movement loop - smooth hold-to-move gameplay */
      let lastMoveTime = 0;
      const moveDelay = 120; // milliseconds between moves when holding
      
      function attemptMove(dirKey) {
        // Called from game loop when key is held
        if (replayMode || gameWon) return false;
        
        let nx = player.x,
          ny = player.y;
        if (dirKey === "w" || dirKey === "ArrowUp") ny--;
        if (dirKey === "s" || dirKey === "ArrowDown") ny++;
        if (dirKey === "a" || dirKey === "ArrowLeft") nx--;
        if (dirKey === "d" || dirKey === "ArrowRight") nx++;
        
        /* Check bounds and wall collision (0 = path, 1 = wall) */
        if (maze[ny] && maze[ny][nx] === 0) {
          player.x = nx;
          player.y = ny;
          const t = startTime ? Math.max(0, Math.round(now() - startTime)) : 0;
          moves.push({ x: nx, y: ny, t });
          // Track breadcrumbs and steps
          visitedCells.add(`${nx},${ny}`);
          totalSteps++;
          localStorage.setItem("maze_total_steps", totalSteps);
          // Show minimap for large mazes
          if (size > 25) {
            document.getElementById("minimap-container").classList.remove("d-none");
            renderMinimap();
          }
          renderMaze();
          playSound("step");
          checkVictory();
          return true;
        }
        playSound("wall");
        return false;
      }
      
      function gameLoopTick() {
        // Run continuous movement check
        if (!startTime || replayMode || gameWon) return;
        
        const now_time = now();
        if (now_time - lastMoveTime < moveDelay) return;
        
        // Check all held keys and move in priority order
        if (keys["w"] || keys["ArrowUp"]) {
          if (attemptMove("w")) lastMoveTime = now_time;
        } else if (keys["s"] || keys["ArrowDown"]) {
          if (attemptMove("s")) lastMoveTime = now_time;
        } else if (keys["a"] || keys["ArrowLeft"]) {
          if (attemptMove("a")) lastMoveTime = now_time;
        } else if (keys["d"] || keys["ArrowRight"]) {
          if (attemptMove("d")) lastMoveTime = now_time;
        }
      }
      
      setInterval(gameLoopTick, 30); // Run game loop ~33fps
      
      document.addEventListener("keydown", (e) => {
        // Player movement: avoid replay/win/input states
        if (replayMode || gameWon) return;
        if (document.activeElement.tagName === "INPUT") return;
        const key = e.key;
        if (
          ![
            "w",
            "a",
            "s",
            "d",
            "ArrowUp",
            "ArrowDown",
            "ArrowLeft",
            "ArrowRight",
          ].includes(key)
        )
          return;
        e.preventDefault();
        if (!keys[key]) {
          keys[key] = true;
          updateKeystrokes();
          if (!startTime) startStopwatch();
          // Immediate first move on key press
          lastMoveTime = 0;
        }
      });
      document.addEventListener("keyup", (e) => {
         if (
           [
             "w",
             "a",
             "s",
             "d",
             "ArrowUp",
             "ArrowDown",
             "ArrowLeft",
             "ArrowRight",
           ].includes(e.key)
         ) {
           keys[e.key] = false;
           updateKeystrokes();
         }
       });

      /* ========== TOUCH CONTROLS (MOBILE) ========== */
      let touchStartX = 0;
      let touchStartY = 0;

      document.addEventListener(
        "touchstart",
        function (evt) {
          touchStartX = evt.changedTouches[0].screenX;
          touchStartY = evt.changedTouches[0].screenY;
        },
        false
      );

      document.addEventListener(
        "touchend",
        function (evt) {
          if (replayMode || gameWon) return;

          let touchEndX = evt.changedTouches[0].screenX;
          let touchEndY = evt.changedTouches[0].screenY;

          handleSwipe(touchStartX, touchEndX, touchStartY, touchEndY);
        },
        false
      );

      function handleSwipe(startX, endX, startY, endY) {
        let xDiff = endX - startX;
        let yDiff = endY - startY;

        // Minimum swipe distance to trigger move (prevents accidental taps)
        if (Math.abs(xDiff) < 30 && Math.abs(yDiff) < 30) return;

        if (Math.abs(xDiff) > Math.abs(yDiff)) {
          // Horizontal Swipe
          if (xDiff > 0) attemptMove("d"); // Right
          else attemptMove("a"); // Left
        } else {
          // Vertical Swipe
          if (yDiff > 0) attemptMove("s"); // Down
          else attemptMove("w"); // Up
        }
      }

       function startStopwatch() {
        // Begin timer, update display every 30ms
        startTime = now();
        stopwatchDisplay.textContent = formatTime(0);
        timerInterval = setInterval(() => {
          stopwatchDisplay.textContent = formatTime(
            Math.round(now() - startTime),
          );
        }, 30);
      }
      function stopStopwatch() {
        clearInterval(timerInterval);
        timerInterval = null;
      }
      function resetStopwatch() {
        stopStopwatch();
        startTime = null;
        stopwatchDisplay.textContent = "00:00.000";
      }

      /* Victory detection: check if player reached end cell, award XP and save run */
      function checkVictory() {
        if (player.x === endCell.x && player.y === endCell.y && !gameWon) {
          gameWon = true;
          stopStopwatch();
          const totalTime = Math.round(now() - (startTime || now()));
          addXP(50);
          saveRun(totalTime);
          // Particle effects on victory
          createParticles(window.innerWidth / 2, window.innerHeight / 2, "confetti", 12);
          playSound("win");
          checkAchievements(totalTime);
          showVictory(totalTime);
        }
      }
      function showVictory(totalTime) {
        // Overlay with timer, replay and menu buttons
        const overlay = document.createElement("div");
        Object.assign(overlay.style, {
          position: "absolute",
          inset: "0",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          background: "rgba(0,0,0,0.8)",
          zIndex: 9999,
        });
        const title = document.createElement("h1");
        title.innerHTML = '<i class="bi bi-trophy" style="color: gold; margin-right: 10px;"></i>VICTORY!';
        title.style.color = "gold";
        title.style.fontSize = "48px";
        const timeText = document.createElement("h4");
        timeText.innerText = `Time: ${formatTime(totalTime)}`;
        timeText.style.color = "#fff";
        
        const buttonContainer = document.createElement("div");
        buttonContainer.style.cssText = "display: flex; gap: 10px; margin-top: 20px; flex-wrap: wrap; justify-content: center;";
        
        const replayBtn = document.createElement("button");
        replayBtn.className = "btn btn-primary mt-3";
        replayBtn.textContent = "Replay Run";
        replayBtn.onclick = () => {
          overlay.remove();
          const last = leaderboard[leaderboard.length - 1];
          if (last) playReplay(last);
        };
        
        const shareBtn = document.createElement("button");
        shareBtn.className = "btn btn-info mt-3";
        shareBtn.innerHTML = '<i class="bi bi-upload"></i> Share Challenge';
        shareBtn.onclick = () => {
          if (currentSeed !== null) {
            const sizeParam = gameSettings.difficulty === "hard" ? "hard" : "medium";
            const challengeUrl = `${window.location.origin}${window.location.pathname}?seed=${currentSeed}&size=${sizeParam}`;
            
            // Try Web Share API first
            if (navigator.share) {
              navigator.share({
                title: "SuperMaze Challenge",
                text: `Beat my maze time: ${formatTime(totalTime)}!`,
                url: challengeUrl
              }).catch(err => console.log("Share cancelled or failed"));
            } else {
              // Fallback: copy to clipboard
              navigator.clipboard.writeText(challengeUrl).then(() => {
                alert(`âœ… Challenge link copied to clipboard!\n\n${challengeUrl}`);
              }).catch(() => {
                // Manual copy as last resort
                const textarea = document.createElement("textarea");
                textarea.value = challengeUrl;
                document.body.appendChild(textarea);
                textarea.select();
                document.execCommand("copy");
                document.body.removeChild(textarea);
                alert(`âœ… Challenge link copied!\n\n${challengeUrl}`);
              });
            }
          }
        };
        
        const menuBtn = document.createElement("button");
        menuBtn.className = "btn btn-secondary mt-3";
        menuBtn.textContent = "Return to Menu";
        menuBtn.onclick = () => {
          overlay.remove();
          mazeScreen.classList.add("d-none");
          connectScreen.classList.remove("d-none");
          resetGame();
        };
        
        buttonContainer.append(replayBtn, shareBtn, menuBtn);
        overlay.append(title, timeText, buttonContainer);
        mazeScreen.appendChild(overlay);
      }

      function addXP(amount) {
        // Award points and update level (100 XP per level)
        xp += amount;
        level = Math.floor(xp / 100);
        localStorage.setItem("maze_xp", xp);
        updateXPDisplay();
      }
      function saveRun(time) {
        // Persist completed run to leaderboard with maze snapshot
        const run = {
          username: sanitizeUsername(username) || "Guest",
          time,
          moves: moves.slice(),
          xp,
          date: new Date().toISOString(),
          mazeSnapshot: clone2D(maze), // Enable replays without server
          startPos: { ...(moves.length ? moves[0] : player) },
        };
        leaderboard.push(run);
        localStorage.setItem("maze_leaderboard", JSON.stringify(leaderboard));
      }

      /* Replay playback: step through moves at 100ms intervals on original maze */
      function playReplay(run) {
        gameWon = false;
        replayMode = true;
        maze = clone2D(run.mazeSnapshot);
        moves = run.moves.slice();
        player = { x: run.startPos.x || 1, y: run.startPos.y || 1 };

        let moveIndex = 0;
        resetStopwatch();
        renderMaze();

        /* Step through recorded moves every 100ms, update elapsed time */
        const replayInterval = setInterval(() => {
          if (moveIndex >= moves.length) {
            clearInterval(replayInterval);
            replayMode = false;
            return;
          }
          const move = moves[moveIndex];
          player.x = move.x;
          player.y = move.y;
          stopwatchDisplay.textContent = formatTime(move.t || 0);
          renderMaze();
          moveIndex++;
        }, 100);
      }

      /* Check and unlock achievements */
      function checkAchievements(elapsedMs) {
        // Speed Demon: Hard maze in under 30s
        if (gameSettings.difficulty === "hard" && elapsedMs < 30000 && !achievements.speedDemon) {
          achievements.speedDemon = true;
          xp += 100;
          alert("âš¡ Speed Demon Unlocked! +100 XP");
        }

        // Marathon: 10,000 total steps
        if (totalSteps >= 10000 && !achievements.marathon) {
          achievements.marathon = true;
          xp += 50;
          alert("ðŸŽ–ï¸ Marathon Unlocked! +50 XP");
        }

        localStorage.setItem("maze_achievements", JSON.stringify(achievements));
        localStorage.setItem("maze_xp", xp);
        level = Math.floor(xp / 100);
        updateXPDisplay();
      }

      /* Show shop modal for unlocking cosmetics and themes */
      function showShopModal() {
        const modal = document.createElement("div");
        Object.assign(modal.style, {
          position: "fixed",
          inset: "0",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "rgba(0,0,0,0.8)",
          zIndex: 50001,
        });

        const content = document.createElement("div");
        Object.assign(content.style, {
          background: "rgba(40, 40, 50, 0.95)",
          borderRadius: "12px",
          padding: "30px",
          textAlign: "center",
          color: "#fff",
          maxHeight: "80vh",
          overflowY: "auto",
          minWidth: "400px",
        });

        const title = document.createElement("h3");
        title.innerHTML = '<i class="bi bi-bag-check"></i> Shop';
        title.style.marginBottom = "10px";
        content.appendChild(title);

        const balance = document.createElement("p");
        balance.innerHTML = `<i class="bi bi-coin"></i> XP Balance: ${xp}`;
        balance.style.marginBottom = "20px";
        balance.style.color = "#ffeaa7";
        content.appendChild(balance);

        // Shop items
        const items = [
          { name: "Gold Theme", cost: 1000, desc: "Exclusive golden color theme", id: "gold-theme" },
          { name: "Red Player Skin", cost: 500, desc: "Ruby-red player avatar", id: "red-skin" },
          { name: "Cyan Player Skin", cost: 500, desc: "Neon cyan player avatar", id: "cyan-skin" },
          { name: "Ghost Enemy Pack", cost: 750, desc: "Enable moving obstacles", id: "ghost-pack" },
        ];

        items.forEach((item) => {
          const itemDiv = document.createElement("div");
          itemDiv.style.cssText = `
            background: rgba(60,60,70,0.6);
            padding: 12px;
            margin-bottom: 10px;
            border-radius: 8px;
            border: 1px solid rgba(255,255,255,0.1);
            display: flex;
            justify-content: space-between;
            align-items: center;
          `;

          const info = document.createElement("div");
          info.style.textAlign = "left";
          info.innerHTML = `<strong>${item.name}</strong><br><small>${item.desc}</small>`;

          const btnWrapper = document.createElement("div");
          const btn = document.createElement("button");
          btn.className = "btn btn-sm " + (xp >= item.cost ? "btn-info" : "btn-secondary");
          btn.textContent = item.cost + " XP";
          btn.disabled = xp < item.cost;
          btn.onclick = () => {
            if (xp >= item.cost) {
              xp -= item.cost;
              localStorage.setItem("maze_xp", xp);
              localStorage.setItem("maze_unlocked_" + item.id, "true");
              alert(`<i class="bi bi-check-circle"></i> Unlocked: ${item.name}!`);
              updateXPDisplay();
              modal.remove();
              showShopModal();
            }
          };
          btnWrapper.appendChild(btn);

          itemDiv.appendChild(info);
          itemDiv.appendChild(btnWrapper);
          content.appendChild(itemDiv);
        });

        const closeBtn = document.createElement("button");
        closeBtn.className = "btn btn-secondary w-100 mt-3";
        closeBtn.textContent = "Close";
        closeBtn.onclick = () => modal.remove();
        content.appendChild(closeBtn);

        modal.appendChild(content);
        document.body.appendChild(modal);
      }

      /* Export maze to JSON format */
      function exportMazeAsJSON(mazeData) {
        const data = {
          version: "1.0",
          type: "supermaze",
          size: size,
          maze: mazeData,
          startPos: { x: 1, y: 1 },
          endPos: { x: size - 2, y: size - 2 },
          createdAt: new Date().toISOString(),
        };
        return JSON.stringify(data, null, 2);
      }

      /* Export maze to XML format */
      function exportMazeAsXML(mazeData) {
        let xml = '<?xml version="1.0" encoding="UTF-8"?>\n';
        xml += '<maze version="1.0" type="supermaze">\n';
        xml += `  <size>${size}</size>\n`;
        xml += `  <startPos x="1" y="1"/>\n`;
        xml += `  <endPos x="${size - 2}" y="${size - 2}"/>\n`;
        xml += `  <createdAt>${new Date().toISOString()}</createdAt>\n`;
        xml += "  <grid>\n";
        mazeData.forEach((row, y) => {
          xml += "    <row>";
          row.forEach((cell) => {
            xml += cell;
          });
          xml += "</row>\n";
        });
        xml += "  </grid>\n";
        xml += "</maze>";
        return xml;
      }

      /* Download file to user's device */
      function downloadFile(content, filename, type) {
        const blob = new Blob([content], { type: type });
        const url = URL.createObjectURL(blob);
        const a = document.createElement("a");
        a.href = url;
        a.download = filename;
        document.body.appendChild(a);
        a.click();
        document.body.removeChild(a);
        URL.revokeObjectURL(url);
      }

      /* Show export format selector modal */
      function showExportModal(mazeData) {
        const modal = document.createElement("div");
        Object.assign(modal.style, {
          position: "fixed",
          inset: "0",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "rgba(0,0,0,0.8)",
          zIndex: 50001,
        });

        const content = document.createElement("div");
        Object.assign(content.style, {
          background: "rgba(40, 40, 50, 0.95)",
          borderRadius: "12px",
          padding: "30px",
          textAlign: "center",
          color: "#fff",
          minWidth: "300px",
        });

        const title = document.createElement("h3");
        title.textContent = "ðŸ“¥ Export Maze Design";
        title.style.marginBottom = "20px";
        content.appendChild(title);

        const jsonBtn = document.createElement("button");
        jsonBtn.className = "btn btn-primary";
        jsonBtn.textContent = "Export as JSON";
        jsonBtn.style.marginRight = "10px";
        jsonBtn.onclick = () => {
          const json = exportMazeAsJSON(mazeData);
          downloadFile(json, "maze_design.json", "application/json");
          modal.remove();
          alert("âœ… Maze exported as JSON!");
        };

        const xmlBtn = document.createElement("button");
        xmlBtn.className = "btn btn-info";
        xmlBtn.textContent = "Export as XML";
        xmlBtn.style.marginRight = "10px";
        xmlBtn.onclick = () => {
          const xml = exportMazeAsXML(mazeData);
          downloadFile(xml, "maze_design.xml", "application/xml");
          modal.remove();
          alert("âœ… Maze exported as XML!");
        };

        const cancelBtn = document.createElement("button");
        cancelBtn.className = "btn btn-secondary";
        cancelBtn.textContent = "Cancel";
        cancelBtn.onclick = () => modal.remove();

        content.append(jsonBtn, xmlBtn, cancelBtn);
        modal.appendChild(content);
        document.body.appendChild(modal);
      }

      /* Leaderboard: sorted by fastest time, clickable to replay */
      function showLeaderboard() {
        const overlay = document.createElement("div");
        Object.assign(overlay.style, {
          position: "fixed",
          inset: "0",
          display: "flex",
          flexDirection: "column",
          justifyContent: "center",
          alignItems: "center",
          background: "rgba(0,0,0,0.9)",
          zIndex: 10000,
          overflow: "auto",
          padding: "20px",
        });

        const title = document.createElement("h2");
        title.innerHTML = '<i class="bi bi-trophy" style="color: gold;"></i> Leaderboard';
        title.style.color = "gold";
        title.style.marginBottom = "20px";

        const list = document.createElement("ol");
        list.style.color = "#fff";
        list.style.textAlign = "left";
        list.style.maxWidth = "500px";

        if (leaderboard.length === 0) {
          const emptyMsg = document.createElement("li");
          emptyMsg.textContent = "No runs yet! Complete a maze to appear here.";
          list.appendChild(emptyMsg);
        } else {
          /* Sort by time ascending; each run is clickable to play replay */
          leaderboard
            .slice()
            .sort((a, b) => a.time - b.time)
            .forEach((run, idx) => {
              const liContainer = document.createElement("div");
              liContainer.style.marginBottom = "10px";
              liContainer.style.display = "flex";
              liContainer.style.gap = "8px";
              liContainer.style.alignItems = "center";

              const li = document.createElement("div");
              li.textContent = `${run.username} - ${formatTime(run.time)}`;
              li.style.flex = "1";
              li.style.cursor = "pointer";
              li.style.padding = "8px";
              li.style.borderRadius = "4px";
              li.style.backgroundColor = "rgba(255,255,255,0.05)";
              li.onmouseover = () =>
                (li.style.background = "rgba(255,255,255,0.1)");
              li.onmouseout = () =>
                (li.style.background = "rgba(255,255,255,0.05)");
              li.onclick = () => {
                overlay.remove();
                playReplay(run);
                connectScreen.classList.add("d-none");
                mazeScreen.classList.remove("d-none");
              };

              const exportBtn = document.createElement("button");
              exportBtn.className = "btn btn-sm btn-outline-info";
              exportBtn.textContent = "ðŸ“¥";
              exportBtn.title = "Export maze design";
              exportBtn.style.padding = "4px 10px";
              exportBtn.style.fontSize = "12px";
              exportBtn.onclick = (e) => {
                e.stopPropagation();
                showExportModal(run.mazeSnapshot);
              };

              liContainer.appendChild(li);
              liContainer.appendChild(exportBtn);
              list.appendChild(liContainer);
            });
        }

        const closeBtn = document.createElement("button");
        closeBtn.className = "btn btn-secondary mt-3";
        closeBtn.textContent = "Close";
        closeBtn.onclick = () => overlay.remove();

        overlay.append(title, list, closeBtn);
        document.body.appendChild(overlay);
      }

      /* Settings: difficulty/graphics dropdowns + editable JSON with line numbers */
      function showSettingsModal() {
        const modal = document.createElement("div");
        modal.className = "settings-modal";

        const content = document.createElement("div");
        content.className = "settings-content";

        const title = document.createElement("h2");
        title.className = "settings-title";
        title.innerHTML = '<i class="bi bi-sliders"></i> Game Settings';
        content.appendChild(title);

        const diffGroup = document.createElement("div");
        diffGroup.className = "settings-group";
        const diffLabel = document.createElement("label");
        diffLabel.textContent = "Difficulty";
        const diffSelect = document.createElement("select");
        diffSelect.id = "setting-difficulty";
        ["easy", "medium", "hard"].forEach((diff) => {
          const opt = document.createElement("option");
          opt.value = diff;
          opt.textContent = diff.charAt(0).toUpperCase() + diff.slice(1);
          if (diff === gameSettings.difficulty) opt.selected = true;
          diffSelect.appendChild(opt);
        });
        diffGroup.appendChild(diffLabel);
        diffGroup.appendChild(diffSelect);
        content.appendChild(diffGroup);

        const gfxGroup = document.createElement("div");
        gfxGroup.className = "settings-group";
        const gfxLabel = document.createElement("label");
        gfxLabel.textContent = "Graphics Mode";
        const gfxSelect = document.createElement("select");
        gfxSelect.id = "setting-graphics";
        ["low", "mid", "high", "advanced"].forEach((gfx) => {
          const opt = document.createElement("option");
          opt.value = gfx;
          opt.textContent = gfx.charAt(0).toUpperCase() + gfx.slice(1);
          if (gfx === gameSettings.graphics) opt.selected = true;
          gfxSelect.appendChild(opt);
        });
        gfxGroup.appendChild(gfxLabel);
        gfxGroup.appendChild(gfxSelect);
        content.appendChild(gfxGroup);

        const jsonGroup = document.createElement("div");
        jsonGroup.className = "settings-group";
        const jsonLabel = document.createElement("label");
        jsonLabel.textContent = "Settings (JSON)";

        /* Code editor with gutter for line numbers; scrolls in sync */
        const editorWrapper = document.createElement("div");
        editorWrapper.className = "code-editor-wrapper";
        editorWrapper.style.height = "250px";

        const lineNumbers = document.createElement("div");
        lineNumbers.className = "code-line-numbers";
        lineNumbers.id = "line-numbers";

        const codeEditor = document.createElement("textarea");
        codeEditor.className = "code-editor";
        codeEditor.id = "code-editor";
        codeEditor.value = JSON.stringify(gameSettings, null, 2);
        codeEditor.spellcheck = false;

        editorWrapper.appendChild(lineNumbers);
        editorWrapper.appendChild(codeEditor);

        jsonGroup.appendChild(jsonLabel);
        jsonGroup.appendChild(editorWrapper);
        const jsonInfo = document.createElement("div");
        jsonInfo.className = "settings-info";
        jsonInfo.textContent = "Edit JSON directly or use dropdowns above";
        jsonGroup.appendChild(jsonInfo);
        content.appendChild(jsonGroup);

        // Buttons
        const btnGroup = document.createElement("div");
        btnGroup.className = "settings-buttons";
        const shopBtn = document.createElement("button");
        shopBtn.className = "save-btn";
        shopBtn.innerHTML = '<i class="bi bi-bag-check"></i> Shop';
        shopBtn.onclick = () => {
          modal.remove();
          showShopModal();
        };
        const saveBtn = document.createElement("button");
        saveBtn.className = "save-btn";
        saveBtn.innerHTML = '<i class="bi bi-download"></i> Save & Exit';
        const closeBtn = document.createElement("button");
        closeBtn.className = "close-btn";
        closeBtn.textContent = "Cancel";
        btnGroup.appendChild(shopBtn);
        btnGroup.appendChild(saveBtn);
        btnGroup.appendChild(closeBtn);
        content.appendChild(btnGroup);

        modal.appendChild(content);
        document.body.appendChild(modal);

        const updateLineNumbers = () => {
          // Recount lines and rebuild gutter
          const lines = codeEditor.value.split("\n").length;
          lineNumbers.innerHTML = Array.from(
            { length: lines },
            (_, i) => i + 1,
          ).join("<br>");
        };

        updateLineNumbers();

        /* Refresh line count on text change; keep gutter scrolled with editor */
        codeEditor.addEventListener("input", updateLineNumbers);
        codeEditor.addEventListener("scroll", () => {
          lineNumbers.scrollTop = codeEditor.scrollTop;
        });

        /* Dropdowns sync to JSON editor; parse and update both views */
        diffSelect.onchange = () => {
          try {
            const current = JSON.parse(codeEditor.value);
            current.difficulty = diffSelect.value;
            codeEditor.value = JSON.stringify(current, null, 2);
            updateLineNumbers();
          } catch (e) {}
        };

        gfxSelect.onchange = () => {
          try {
            const current = JSON.parse(codeEditor.value);
            current.graphics = gfxSelect.value;
            codeEditor.value = JSON.stringify(current, null, 2);
            updateLineNumbers();
          } catch (e) {}
        };

        /* Parse JSON and validate required fields before saving */
        saveBtn.onclick = () => {
          try {
            const settings = JSON.parse(codeEditor.value);
            if (settings.difficulty && settings.graphics) {
              gameSettings = settings;
              localStorage.setItem(
                "maze_game_settings",
                JSON.stringify(settings),
              );
              modal.remove();
              alert("âœ… Settings saved!");
            } else {
              alert(
                "âŒ Invalid settings! Need 'difficulty' and 'graphics' fields.",
              );
            }
          } catch (e) {
            alert("âŒ Invalid JSON: " + e.message);
          }
        };

        closeBtn.onclick = () => modal.remove();
      }

      function resetGame() {
        // Regenerate maze, clear moves, reset win/replay flags
        generateMaze();
        renderMaze();
        moves = [];
        gameWon = false;
        replayMode = false;
        resetStopwatch();
        visitedCells.clear(); // Clear breadcrumbs
        document.getElementById("minimap-container").classList.add("d-none");
      }

      /* Parse JSON/XML maze file */
      function parseMazeFile(content) {
        try {
          // Try JSON first
          const jsonData = JSON.parse(content);
          if (jsonData.maze && Array.isArray(jsonData.maze)) {
            maze = clone2D(jsonData.maze);
            size = jsonData.size || 21;
            cellPx = 25;
            player = jsonData.startPos || { x: 1, y: 1 };
            endCell = jsonData.endPos || { x: size - 2, y: size - 2 };
            return true;
          }
        } catch {
          // Try XML
          try {
            const parser = new DOMParser();
            const xmlDoc = parser.parseFromString(content, "application/xml");
            if (xmlDoc.getElementsByTagName("maze").length > 0) {
              const sizeEl = xmlDoc.querySelector("size");
              size = parseInt(sizeEl?.textContent) || 21;
              cellPx = 25;

              const startEl = xmlDoc.querySelector("startPos");
              player = {
                x: parseInt(startEl?.getAttribute("x")) || 1,
                y: parseInt(startEl?.getAttribute("y")) || 1,
              };

              const endEl = xmlDoc.querySelector("endPos");
              endCell = {
                x: parseInt(endEl?.getAttribute("x")) || size - 2,
                y: parseInt(endEl?.getAttribute("y")) || size - 2,
              };

              const rows = xmlDoc.querySelectorAll("row");
              maze = [];
              rows.forEach((row) => {
                const cells = row.textContent.split("").map((c) => parseInt(c));
                if (cells.length > 0) maze.push(cells);
              });

              return maze.length > 0;
            }
          } catch {}
        }
        return false;
      }

      /* Show modal for choosing random or import maze */
      function showMazeImportDialog() {
        const modal = document.createElement("div");
        Object.assign(modal.style, {
          position: "fixed",
          inset: "0",
          display: "flex",
          justifyContent: "center",
          alignItems: "center",
          background: "rgba(0,0,0,0.8)",
          zIndex: 50001,
        });

        const content = document.createElement("div");
        Object.assign(content.style, {
          background: "rgba(40, 40, 50, 0.95)",
          borderRadius: "12px",
          padding: "30px",
          textAlign: "center",
          color: "#fff",
          minWidth: "350px",
        });

        const title = document.createElement("h3");
        title.innerHTML = '<i class="bi bi-controller"></i> Start New Game';
        title.style.marginBottom = "20px";
        content.appendChild(title);

        const dailyBtn = document.createElement("button");
        dailyBtn.className = "btn btn-primary";
        const today = new Date().toISOString().split("T")[0];
        dailyBtn.innerHTML = `<i class="bi bi-calendar-event"></i> Daily Challenge (${today})`;
        dailyBtn.style.marginRight = "10px";
        dailyBtn.style.marginBottom = "10px";
        dailyBtn.onclick = () => {
          modal.remove();
          connectScreen.classList.add("d-none");
          mazeScreen.classList.remove("d-none");
          resetGame();
          generateDailyChallenge();
          renderMaze();
          moves = [];
          gameWon = false;
          replayMode = false;
          resetStopwatch();
        };

        const randomBtn = document.createElement("button");
        randomBtn.className = "btn btn-success";
        randomBtn.innerHTML = '<i class="bi bi-shuffle"></i> Random Maze';
        randomBtn.style.marginRight = "10px";
        randomBtn.style.marginBottom = "10px";
        randomBtn.onclick = () => {
          modal.remove();
          connectScreen.classList.add("d-none");
          mazeScreen.classList.remove("d-none");
          resetGame();
        };

        const fileBtn = document.createElement("button");
        fileBtn.className = "btn btn-info";
        fileBtn.innerHTML = '<i class="bi bi-folder-open"></i> Load from File';
        fileBtn.style.marginRight = "10px";
        fileBtn.style.marginBottom = "10px";
        fileBtn.onclick = () => {
          const input = document.createElement("input");
          input.type = "file";
          input.accept = ".json,.xml";
          input.onchange = (e) => {
            const file = e.target.files[0];
            if (!file) return;

            const reader = new FileReader();
            reader.onload = (event) => {
              const content = event.target.result;
              if (parseMazeFile(content)) {
                modal.remove();
                connectScreen.classList.add("d-none");
                mazeScreen.classList.remove("d-none");
                moves = [];
                gameWon = false;
                replayMode = false;
                resetStopwatch();
                renderMaze();
                alert("âœ… Maze loaded successfully!");
              } else {
                alert("âŒ Invalid maze file format!");
              }
            };
            reader.readAsText(file);
          };
          input.click();
        };

        const cancelBtn = document.createElement("button");
        cancelBtn.className = "btn btn-secondary";
        cancelBtn.textContent = "Cancel";
        cancelBtn.onclick = () => modal.remove();

        content.append(
          dailyBtn,
          randomBtn,
          fileBtn,
          document.createElement("br"),
          cancelBtn,
        );
        modal.appendChild(content);
        document.body.appendChild(modal);
      }

      /* Button event handlers */
      singleBtn.onclick = () => {
        showMazeImportDialog();
      };

      replayListBtn.onclick = () => {
        showLeaderboard();
      };

      leaderboardBtn.onclick = () => {
        showLeaderboard();
      };

      settingsBtn.onclick = () => {
        showSettingsModal();
      };

      docsBtn.onclick = () => {
        window.open("https://kessud2021.github.io/supermaze-docs/", "_blank");
      };

      backBtn.onclick = () => {
        mazeScreen.classList.add("d-none");
        connectScreen.classList.remove("d-none");
        resetGame();
      };

      logoutBtn.onclick = logout;
    </script>

    <!-- jQuery-like Utility Library -->
    <script class="jquery-code">
      /* ========== INSANE JQUERY-LIKE UTILITIES ========== */

      const $util = {
        // === SELECTORS ===

        // Get single element
        id: (id) => document.getElementById(id),

        // Get all matching elements
        select: (selector) => document.querySelectorAll(selector),

        // Get first matching element
        query: (selector) => document.querySelector(selector),

        // Get by class
        byClass: (className) => document.querySelectorAll("." + className),

        // Get by tag
        byTag: (tag) => document.querySelectorAll(tag),

        // === ELEMENT CREATION ===

        // Create element with optional class and text
        create: (tag, className = "", text = "") => {
          const el = document.createElement(tag);
          if (className) el.className = className;
          if (text) el.textContent = text;
          return el;
        },

        // Create button
        button: (text, className = "btn btn-primary") => {
          const btn = $util.create("button", className, text);
          return btn;
        },

        // Create div with content
        div: (className = "", content = "") => {
          const d = $util.create("div", className);
          if (content) d.innerHTML = content;
          return d;
        },

        // === CLASS MANIPULATION ===

        // Add class(es)
        addClass: (el, className) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.classList.add(...className.split(" ")));
          } else {
            el.classList.add(...className.split(" "));
          }
          return el;
        },

        // Remove class(es)
        removeClass: (el, className) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.classList.remove(...className.split(" ")));
          } else {
            el.classList.remove(...className.split(" "));
          }
          return el;
        },

        // Toggle class
        toggleClass: (el, className) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.classList.toggle(className));
          } else {
            el.classList.toggle(className);
          }
          return el;
        },

        // Check if has class
        hasClass: (el, className) => el.classList.contains(className),

        // === STYLE MANIPULATION ===

        // Set CSS styles
        css: (el, styles) => {
          if (Array.isArray(el)) {
            el.forEach((e) => Object.assign(e.style, styles));
          } else {
            Object.assign(el.style, styles);
          }
          return el;
        },

        // Get computed style
        getStyle: (el, prop) =>
          window.getComputedStyle(el).getPropertyValue(prop),

        // Show element
        show: (el) => $util.css(el, { display: "block" }),

        // Hide element
        hide: (el) => $util.css(el, { display: "none" }),

        // Toggle visibility
        toggle: (el) => {
          const display = $util.getStyle(el, "display");
          $util.css(el, { display: display === "none" ? "block" : "none" });
          return el;
        },

        // Fade in
        fadeIn: (el, duration = 300) => {
          el.style.opacity = "0";
          el.style.display = "block";
          el.style.transition = `opacity ${duration}ms ease-in`;
          setTimeout(() => (el.style.opacity = "1"), 10);
          return el;
        },

        // Fade out
        fadeOut: (el, duration = 300, hide = true) => {
          el.style.transition = `opacity ${duration}ms ease-out`;
          el.style.opacity = "0";
          if (hide) {
            setTimeout(() => (el.style.display = "none"), duration);
          }
          return el;
        },

        // Slide down
        slideDown: (el, duration = 300) => {
          el.style.height = "0";
          el.style.overflow = "hidden";
          el.style.transition = `height ${duration}ms ease-out`;
          setTimeout(() => (el.style.height = el.scrollHeight + "px"), 10);
          setTimeout(() => {
            el.style.height = "auto";
            el.style.transition = "";
          }, duration);
          return el;
        },

        // Slide up
        slideUp: (el, duration = 300) => {
          el.style.height = el.scrollHeight + "px";
          el.style.overflow = "hidden";
          el.style.transition = `height ${duration}ms ease-in`;
          setTimeout(() => (el.style.height = "0"), 10);
          setTimeout(() => (el.style.display = "none"), duration);
          return el;
        },

        // === TEXT & HTML ===

        // Get/set text
        text: (el, value) => {
          if (value !== undefined) {
            if (Array.isArray(el)) {
              el.forEach((e) => (e.textContent = value));
            } else {
              el.textContent = value;
            }
            return el;
          }
          return el.textContent;
        },

        // Get/set HTML
        html: (el, value) => {
          if (value !== undefined) {
            if (Array.isArray(el)) {
              el.forEach((e) => (e.innerHTML = value));
            } else {
              el.innerHTML = value;
            }
            return el;
          }
          return el.innerHTML;
        },

        // Get/set value
        val: (el, value) => {
          if (value !== undefined) {
            el.value = value;
            return el;
          }
          return el.value;
        },

        // Append child(ren)
        append: (parent, ...children) => {
          children.forEach((child) => {
            if (typeof child === "string") {
              parent.insertAdjacentHTML("beforeend", child);
            } else {
              parent.appendChild(child);
            }
          });
          return parent;
        },

        // Prepend child(ren)
        prepend: (parent, ...children) => {
          children.forEach((child, idx) => {
            if (typeof child === "string") {
              parent.insertAdjacentHTML(
                idx === 0 ? "afterbegin" : "beforeend",
                child,
              );
            } else {
              if (idx === 0) {
                parent.insertBefore(child, parent.firstChild);
              } else {
                parent.appendChild(child);
              }
            }
          });
          return parent;
        },

        // Remove element(s)
        remove: (el) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.remove());
          } else {
            el.remove();
          }
        },

        // Empty element (remove all children)
        empty: (el) => {
          if (Array.isArray(el)) {
            el.forEach((e) => (e.innerHTML = ""));
          } else {
            el.innerHTML = "";
          }
          return el;
        },

        // === ATTRIBUTES ===

        // Get/set attribute
        attr: (el, attr, value) => {
          if (value !== undefined) {
            if (Array.isArray(el)) {
              el.forEach((e) => e.setAttribute(attr, value));
            } else {
              el.setAttribute(attr, value);
            }
            return el;
          }
          return el.getAttribute(attr);
        },

        // Get/set multiple attributes
        attrs: (el, attrs) => {
          if (Array.isArray(el)) {
            el.forEach((e) =>
              Object.entries(attrs).forEach(([k, v]) => e.setAttribute(k, v)),
            );
          } else {
            Object.entries(attrs).forEach(([k, v]) => el.setAttribute(k, v));
          }
          return el;
        },

        // Remove attribute
        removeAttr: (el, attr) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.removeAttribute(attr));
          } else {
            el.removeAttribute(attr);
          }
          return el;
        },

        // === DATA ATTRIBUTES ===

        // Get/set data attribute
        data: (el, key, value) => {
          if (value !== undefined) {
            el.dataset[key] = value;
            return el;
          }
          return el.dataset[key];
        },

        // === EVENTS ===

        // Add event listener
        on: (el, event, handler) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.addEventListener(event, handler));
          } else {
            el.addEventListener(event, handler);
          }
          return el;
        },

        // Remove event listener
        off: (el, event, handler) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.removeEventListener(event, handler));
          } else {
            el.removeEventListener(event, handler);
          }
          return el;
        },

        // Click handler
        click: (el, handler) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.addEventListener("click", handler));
          } else {
            el.addEventListener("click", handler);
          }
          return el;
        },

        // Change handler
        change: (el, handler) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.addEventListener("change", handler));
          } else {
            el.addEventListener("change", handler);
          }
          return el;
        },

        // Input handler
        input: (el, handler) => {
          if (Array.isArray(el)) {
            el.forEach((e) => e.addEventListener("input", handler));
          } else {
            el.addEventListener("input", handler);
          }
          return el;
        },

        // Hover handler
        hover: (el, enterHandler, leaveHandler) => {
          if (Array.isArray(el)) {
            el.forEach((e) => {
              e.addEventListener("mouseenter", enterHandler);
              e.addEventListener("mouseleave", leaveHandler || (() => {}));
            });
          } else {
            el.addEventListener("mouseenter", enterHandler);
            el.addEventListener("mouseleave", leaveHandler || (() => {}));
          }
          return el;
        },

        // === TRAVERSAL ===

        // Get parent element
        parent: (el) => el.parentElement,

        // Get all parents
        parents: (el) => {
          const parents = [];
          let current = el.parentElement;
          while (current) {
            parents.push(current);
            current = current.parentElement;
          }
          return parents;
        },

        // Get children
        children: (el, selector = null) => {
          const kids = Array.from(el.children);
          return selector ? kids.filter((k) => k.matches(selector)) : kids;
        },

        // Get siblings
        siblings: (el) => {
          return Array.from(el.parentElement.children).filter((e) => e !== el);
        },

        // Get next sibling
        next: (el) => el.nextElementSibling,

        // Get previous sibling
        prev: (el) => el.previousElementSibling,

        // === DIMENSIONS ===

        // Get width
        width: (el) => el.offsetWidth,

        // Get height
        height: (el) => el.offsetHeight,

        // Get inner width (excluding border)
        innerWidth: (el) => el.clientWidth,

        // Get inner height (excluding border)
        innerHeight: (el) => el.clientHeight,

        // Get outer width (including margin)
        outerWidth: (el, includeMargin = true) => {
          if (!includeMargin) return el.offsetWidth;
          const style = window.getComputedStyle(el);
          return (
            el.offsetWidth +
            parseFloat(style.marginLeft) +
            parseFloat(style.marginRight)
          );
        },

        // Get outer height (including margin)
        outerHeight: (el, includeMargin = true) => {
          if (!includeMargin) return el.offsetHeight;
          const style = window.getComputedStyle(el);
          return (
            el.offsetHeight +
            parseFloat(style.marginTop) +
            parseFloat(style.marginBottom)
          );
        },

        // Get offset (position relative to document)
        offset: (el) => {
          const rect = el.getBoundingClientRect();
          return {
            top: rect.top + window.scrollY,
            left: rect.left + window.scrollX,
          };
        },

        // === ANIMATIONS ===

        // Animate CSS properties
        animate: (el, properties, duration = 300, easing = "ease") => {
          const style = el.style;
          style.transition = `all ${duration}ms ${easing}`;
          Object.assign(el.style, properties);
          setTimeout(() => (style.transition = ""), duration);
          return el;
        },

        // Delay execution
        delay: (ms) => new Promise((resolve) => setTimeout(resolve, ms)),

        // === UTILITY ===

        // Check if element matches selector
        is: (el, selector) => el.matches(selector),

        // Find descendants matching selector
        find: (el, selector) => el.querySelectorAll(selector),

        // Filter elements
        filter: (els, selector) =>
          Array.from(els).filter((e) => e.matches(selector)),

        // Map over elements
        each: (els, callback) => {
          Array.from(els).forEach((el, idx) => callback.call(el, idx, el));
          return els;
        },

        // Get siblings and self
        all: (el) => [el, ...$util.siblings(el)],

        // Ready - execute when DOM is ready
        ready: (fn) => {
          if (document.readyState === "loading") {
            document.addEventListener("DOMContentLoaded", fn);
          } else {
            fn();
          }
        },

        // Extend object (merge properties)
        extend: (target, ...sources) => {
          return Object.assign(target, ...sources);
        },

        // Get parent with selector
        closest: (el, selector) => el.closest(selector),

        // Scroll element into view
        scrollIntoView: (el) => {
          el.scrollIntoView({ behavior: "smooth", block: "center" });
          return el;
        },

        // === BONUS: CHAIN ===
        chain: function (el) {
          return {
            el: el,
            addClass: function (c) {
              $util.addClass(this.el, c);
              return this;
            },
            removeClass: function (c) {
              $util.removeClass(this.el, c);
              return this;
            },
            html: function (h) {
              $util.html(this.el, h);
              return this;
            },
            text: function (t) {
              $util.text(this.el, t);
              return this;
            },
            css: function (s) {
              $util.css(this.el, s);
              return this;
            },
            attr: function (a, v) {
              $util.attr(this.el, a, v);
              return this;
            },
            click: function (h) {
              $util.click(this.el, h);
              return this;
            },
            append: function (...c) {
              $util.append(this.el, ...c);
              return this;
            },
          };
        },
      };

      // Export for console usage
      window.$util = $util;

      /* ========== AUDIO SYSTEM (SYNTHESIS) ========== */
      const audioCtx = new (window.AudioContext || window.webkitAudioContext)();
      let soundEnabled = true;

      function toggleSound() {
        soundEnabled = !soundEnabled;
        if (audioCtx.state === "suspended") audioCtx.resume();
        return soundEnabled;
      }

      function playSound(type) {
        if (!soundEnabled) return;
        if (audioCtx.state === "suspended") audioCtx.resume();

        const osc = audioCtx.createOscillator();
        const gainNode = audioCtx.createGain();

        osc.connect(gainNode);
        gainNode.connect(audioCtx.destination);

        const now = audioCtx.currentTime;

        if (type === "step") {
          // Soft blip
          osc.type = "sine";
          osc.frequency.setValueAtTime(400, now);
          osc.frequency.exponentialRampToValueAtTime(100, now + 0.1);
          gainNode.gain.setValueAtTime(0.1, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          osc.start(now);
          osc.stop(now + 0.1);
        } else if (type === "wall") {
          // Low thud
          osc.type = "square";
          osc.frequency.setValueAtTime(100, now);
          osc.frequency.exponentialRampToValueAtTime(50, now + 0.1);
          gainNode.gain.setValueAtTime(0.1, now);
          gainNode.gain.exponentialRampToValueAtTime(0.01, now + 0.1);
          osc.start(now);
          osc.stop(now + 0.1);
        } else if (type === "win") {
          // Victory arpeggio
          osc.type = "triangle";
          gainNode.gain.setValueAtTime(0.2, now);

          // Play C Major Arpeggio rapidly
          [523.25, 659.25, 783.99, 1046.5].forEach((freq, i) => {
            setTimeout(() => {
              const o = audioCtx.createOscillator();
              const g = audioCtx.createGain();
              o.connect(g);
              g.connect(audioCtx.destination);
              o.type = "triangle";
              o.frequency.value = freq;
              g.gain.setValueAtTime(0.1, audioCtx.currentTime);
              g.gain.exponentialRampToValueAtTime(
                0.01,
                audioCtx.currentTime + 0.2
              );
              o.start();
              o.stop(audioCtx.currentTime + 0.2);
            }, i * 100);
          });
        }
      }

      /* Embedded Service Worker for PWA offline support */
      if ("serviceWorker" in navigator) {
        window.addEventListener("load", () => {
          // Service Worker code embedded as blob
          const swCode = `
const CACHE_VERSION = "v1.3.1";
const CACHE_NAME = \`supermaze-\${CACHE_VERSION}\`;
const ASSETS_TO_CACHE = [
  "/",
  "/index.html",
  "https://cdn.jsdelivr.net/npm/bootstrap@5.3.8/dist/css/bootstrap.min.css",
  "https://code.jquery.com/jquery-3.7.1.slim.min.js",
  "https://cdn.jsdelivr.net/npm/bootstrap-icons@1.13.1/font/bootstrap-icons.min.css"
];

self.addEventListener("install", (event) => {
  event.waitUntil(
    caches.open(CACHE_NAME).then((cache) => {
      return cache
        .addAll(ASSETS_TO_CACHE)
        .catch((error) => {
          console.warn("Cache addAll error:", error);
          return Promise.resolve();
        });
    })
  );
  self.skipWaiting();
});

self.addEventListener("activate", (event) => {
  event.waitUntil(
    caches.keys().then((cacheNames) => {
      return Promise.all(
        cacheNames.map((cacheName) => {
          if (cacheName !== CACHE_NAME) {
            return caches.delete(cacheName);
          }
        })
      );
    })
  );
  self.clients.claim();
});

self.addEventListener("fetch", (event) => {
  if (event.request.method !== "GET") {
    return;
  }

  event.respondWith(
    fetch(event.request)
      .then((response) => {
        if (response.ok) {
          const responseToCache = response.clone();
          caches.open(CACHE_NAME).then((cache) => {
            cache.put(event.request, responseToCache);
          });
        }
        return response;
      })
      .catch(() => {
        return caches.match(event.request).then((response) => {
          return response || new Response("Offline - No cached response available");
        });
      })
  );
});
`;

          const blob = new Blob([swCode], { type: "application/javascript" });
          const swUrl = URL.createObjectURL(blob);

          navigator.serviceWorker
            .register(swUrl, { scope: "/" })
            .then((reg) => {
              console.log("Service Worker registered successfully:", reg);
            })
            .catch((error) => {
              console.log("Service Worker registration failed:", error);
            });
        });
      }
    </script>
  </body>
</html>
